// Generated by Haxe 4.3.6
#include <hxcpp.h>

#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_haxe_format_JsonPrinter
#include <haxe/format/JsonPrinter.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_28_main,"Main","main",0xed0e206e,"Main.main","Main.hx",28,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_48_psychToVSlice,"Main","psychToVSlice",0x1eacf15d,"Main.psychToVSlice","Main.hx",48,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_116_vsliceToPsych,"Main","vsliceToPsych",0x4be72a2f,"Main.vsliceToPsych","Main.hx",116,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_176_awaitInput,"Main","awaitInput",0xef12bac9,"Main.awaitInput","Main.hx",176,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_188_waitAndClose,"Main","waitAndClose",0x3a549a2b,"Main.waitAndClose","Main.hx",188,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_199_closeWithMessage,"Main","closeWithMessage",0xb220e33e,"Main.closeWithMessage","Main.hx",199,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_21_boot,"Main","boot",0xe5d36c67,"Main.boot","Main.hx",21,0x087e5c05)
HX_LOCAL_STACK_FRAME(_hx_pos_e47a9afac0942eb9_26_boot,"Main","boot",0xe5d36c67,"Main.boot","Main.hx",26,0x087e5c05)

void Main_obj::__construct() { }

Dynamic Main_obj::__CreateEmpty() { return new Main_obj; }

void *Main_obj::_hx_vtable = 0;

Dynamic Main_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Main_obj > _hx_result = new Main_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Main_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x07825a7d;
}

int Main_obj::FALIURE;

int Main_obj::SUCCESS;

void Main_obj::main(){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_28_main)
HXLINE(  29)		::Array< ::String > args = ::Sys_obj::args();
HXLINE(  32)		::String _hx_switch_0 = ::Main_obj::awaitInput(HX_("Convert Mode:",4a,e5,a6,b9));
            		if (  (_hx_switch_0==HX_("PSYCH_TO_VSLICE",3c,ae,af,67)) ){
HXLINE(  34)			::Main_obj::psychToVSlice(args);
HXDLIN(  34)			goto _hx_goto_0;
            		}
            		if (  (_hx_switch_0==HX_("VSLICE_TO_PSYCH",da,cf,16,52)) ){
HXLINE(  36)			::Main_obj::vsliceToPsych(args);
HXDLIN(  36)			goto _hx_goto_0;
            		}
            		/* default */{
HXLINE(  38)			::Main_obj::closeWithMessage(HX_("No Conversion Method Specified. Closing...",07,24,95,4f),2,::Main_obj::FALIURE);
            		}
            		_hx_goto_0:;
HXLINE(  41)		::Main_obj::closeWithMessage(HX_("Character Successfully Converted!",51,0d,7c,0c),null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Main_obj,main,(void))

void Main_obj::psychToVSlice(::Array< ::String > args){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_48_psychToVSlice)
HXLINE(  49)		::String fileName;
HXDLIN(  49)		if ((args->length == 0)) {
HXLINE(  49)			fileName = ::Main_obj::awaitInput(HX_("Psych Character JSON:",36,50,37,61));
            		}
            		else {
HXLINE(  49)			fileName = ::StringTools_obj::trim(args->__get(0));
            		}
HXLINE(  51)		if ((::haxe::io::Path_obj::extension(fileName) == HX_("",00,00,00,00))) {
HXLINE(  52)			fileName = (fileName + HX_(".json",56,f1,d6,c2));
            		}
HXLINE(  54)		 ::Dynamic psychJSON = null();
HXLINE(  56)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  57)			psychJSON =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(fileName))->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(  59)				::Main_obj::closeWithMessage(HX_("ERROR: Invalid JSON Data.",23,75,b3,49),2,::Main_obj::FALIURE);
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  62)		::String characterName = ::Main_obj::awaitInput(HX_("Character Name?",9d,13,7d,9a));
HXLINE(  65)		::String characterImage = ( (::String)( ::Dynamic(psychJSON->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic))->__Field(HX_("split",da,ea,6e,81),::hx::paccDynamic)(HX_(",",2c,00,00,00))->__GetItem(0)) );
HXLINE(  67)		 ::haxe::ds::StringMap _g1 =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  67)		_g1->set(HX_("version",18,e7,f1,7c),HX_("1.0.1",b6,d1,2e,55));
HXDLIN(  67)		_g1->set(HX_("name",4b,72,ff,48),characterName);
HXDLIN(  67)		_g1->set(HX_("renderType",30,ed,12,ea),HX_("sparrow",0c,3c,ac,9b));
HXDLIN(  67)		_g1->set(HX_("assetPath",b5,33,f8,ae),characterImage);
HXDLIN(  67)		{
HXLINE(  67)			 ::Dynamic value;
HXLINE(  72)			 ::Dynamic tmp = psychJSON->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic);
HXDLIN(  72)			if (::hx::IsNotNull( tmp )) {
HXLINE(  67)				value = tmp;
            			}
            			else {
HXLINE(  67)				value = ((Float)1.0);
            			}
HXDLIN(  67)			_g1->set(HX_("scale",8a,ce,ce,78),value);
            		}
HXDLIN(  67)		{
HXLINE(  74)			::String tmp1 = ( (::String)(psychJSON->__Field(HX_("healthicon",15,8e,6f,17),::hx::paccDynamic)) );
HXDLIN(  74)			::String value1;
HXDLIN(  74)			if (::hx::IsNotNull( tmp1 )) {
HXLINE(  74)				value1 = tmp1;
            			}
            			else {
HXLINE(  74)				value1 = HX_("face",9d,b4,b5,43);
            			}
HXLINE(  75)			 ::Dynamic tmp2 = psychJSON->__Field(HX_("no_antialiasing",f2,74,67,98),::hx::paccDynamic);
HXDLIN(  75)			bool value2;
HXDLIN(  75)			if (::hx::IsNotNull( tmp2 )) {
HXLINE(  75)				value2 = ( (bool)(tmp2) );
            			}
            			else {
HXLINE(  75)				value2 = false;
            			}
HXLINE(  67)			_g1->set(HX_("healthIcon",35,ba,48,02), ::Dynamic(::hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("id",db,5b,00,00),value1)
            				->setFixed(1,HX_("isPixel",3c,6a,29,5f),value2)));
            		}
HXDLIN(  67)		{
HXLINE(  67)			 ::Dynamic value3;
HXLINE(  77)			::cpp::VirtualArray tmp3 = ( (::cpp::VirtualArray)(psychJSON->__Field(HX_("position",a9,a0,fa,ca),::hx::paccDynamic)) );
HXDLIN(  77)			if (::hx::IsNotNull( tmp3 )) {
HXLINE(  67)				value3 = tmp3;
            			}
            			else {
HXLINE(  67)				value3 = ::cpp::VirtualArray_obj::__new(2)->init(0,0)->init(1,0);
            			}
HXDLIN(  67)			_g1->set(HX_("offsets",80,09,65,d7),value3);
            		}
HXDLIN(  67)		{
HXLINE(  67)			 ::Dynamic value4;
HXLINE(  78)			::cpp::VirtualArray tmp4 = ( (::cpp::VirtualArray)(psychJSON->__Field(HX_("camera_position",c3,d4,4a,56),::hx::paccDynamic)) );
HXDLIN(  78)			if (::hx::IsNotNull( tmp4 )) {
HXLINE(  67)				value4 = tmp4;
            			}
            			else {
HXLINE(  67)				value4 = ::cpp::VirtualArray_obj::__new(2)->init(0,0)->init(1,0);
            			}
HXDLIN(  67)			_g1->set(HX_("cameraOffsets",5b,39,62,df),value4);
            		}
HXDLIN(  67)		{
HXLINE(  67)			 ::Dynamic value5;
HXLINE(  79)			 ::Dynamic tmp5 = psychJSON->__Field(HX_("no_antialiasing",f2,74,67,98),::hx::paccDynamic);
HXDLIN(  79)			if (::hx::IsNotNull( tmp5 )) {
HXLINE(  67)				value5 = tmp5;
            			}
            			else {
HXLINE(  67)				value5 = false;
            			}
HXDLIN(  67)			_g1->set(HX_("isPixel",3c,6a,29,5f),value5);
            		}
HXDLIN(  67)		_g1->set(HX_("danceEvery",68,3f,07,1e),2);
HXDLIN(  67)		{
HXLINE(  67)			 ::Dynamic value6;
HXLINE(  81)			 ::Dynamic tmp6 = psychJSON->__Field(HX_("sing_duration",84,ae,a8,66),::hx::paccDynamic);
HXDLIN(  81)			if (::hx::IsNotNull( tmp6 )) {
HXLINE(  67)				value6 = tmp6;
            			}
            			else {
HXLINE(  67)				value6 = ((Float)8.0);
            			}
HXDLIN(  67)			_g1->set(HX_("singTime",fc,61,54,41),value6);
            		}
HXDLIN(  67)		_g1->set(HX_("startingAnimation",24,95,2d,77),HX_("idle",14,a7,b3,45));
HXDLIN(  67)		_g1->set(HX_("animations",ef,34,1c,83),::cpp::VirtualArray_obj::__new(0));
HXDLIN(  67)		{
HXLINE(  67)			 ::Dynamic value7;
HXLINE(  84)			 ::Dynamic tmp7 = psychJSON->__Field(HX_("flip_x",26,2b,6a,3d),::hx::paccDynamic);
HXDLIN(  84)			if (::hx::IsNotNull( tmp7 )) {
HXLINE(  67)				value7 = tmp7;
            			}
            			else {
HXLINE(  67)				value7 = false;
            			}
HXDLIN(  67)			_g1->set(HX_("flipX",0b,45,92,02),value7);
            		}
HXLINE(  87)		{
HXLINE(  87)			int _g2 = 0;
HXDLIN(  87)			::cpp::VirtualArray _g3 = ::hx::TCast< ::cpp::VirtualArray >::cast( ::Dynamic(psychJSON->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic)));
HXDLIN(  87)			while((_g2 < _g3->get_length())){
HXLINE(  87)				 ::Dynamic animation = _g3->__get(_g2);
HXDLIN(  87)				_g2 = (_g2 + 1);
HXLINE(  88)				::String anim = ( (::String)(animation->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
HXLINE(  89)				if (::StringTools_obj::endsWith(anim,HX_("-loop",11,c1,bf,30))) {
HXLINE(  89)					anim = ::StringTools_obj::replace(anim,HX_("-loop",11,c1,bf,30),HX_("-hold",ec,e3,1a,2e));
            				}
HXLINE(  95)				 ::Dynamic tmp8 = animation->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic);
HXDLIN(  95)				bool _hx_tmp;
HXDLIN(  95)				if (::hx::IsNotNull( tmp8 )) {
HXLINE(  95)					_hx_tmp = ( (bool)(tmp8) );
            				}
            				else {
HXLINE(  95)					_hx_tmp = false;
            				}
HXLINE(  96)				 ::Dynamic tmp9 = animation->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic);
HXDLIN(  96)				int _hx_tmp1;
HXDLIN(  96)				if (::hx::IsNotNull( tmp9 )) {
HXLINE(  96)					_hx_tmp1 = ( (int)(tmp9) );
            				}
            				else {
HXLINE(  96)					_hx_tmp1 = 24;
            				}
HXLINE(  97)				::cpp::VirtualArray tmp10 = ( (::cpp::VirtualArray)(animation->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) );
HXDLIN(  97)				::cpp::VirtualArray _hx_tmp2;
HXDLIN(  97)				if (::hx::IsNotNull( tmp10 )) {
HXLINE(  97)					_hx_tmp2 = tmp10;
            				}
            				else {
HXLINE(  97)					_hx_tmp2 = ::cpp::VirtualArray_obj::__new(0);
            				}
HXLINE(  91)				_g1->get(HX_("animations",ef,34,1c,83))->__Field(HX_("push",da,11,61,4a),::hx::paccDynamic)( ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("frameIndices",7a,06,df,83),_hx_tmp2)
            					->setFixed(1,HX_("prefix",92,d9,b6,ae), ::Dynamic(animation->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)))
            					->setFixed(2,HX_("offsets",80,09,65,d7), ::Dynamic(animation->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))
            					->setFixed(3,HX_("frameRate",ad,11,25,39),_hx_tmp1)
            					->setFixed(4,HX_("name",4b,72,ff,48),anim)
            					->setFixed(5,HX_("looped",c3,5f,b9,61),_hx_tmp)));
HXLINE( 100)				bool _hx_tmp3;
HXDLIN( 100)				if (::StringTools_obj::startsWith(anim,HX_("dance",33,83,83,d4))) {
HXLINE( 100)					_hx_tmp3 = ::hx::IsEq( _g1->get(HX_("startingAnimation",24,95,2d,77)),HX_("idle",14,a7,b3,45) );
            				}
            				else {
HXLINE( 100)					_hx_tmp3 = false;
            				}
HXDLIN( 100)				if (_hx_tmp3) {
HXLINE( 101)					_g1->set(HX_("startingAnimation",24,95,2d,77),HX_("danceRight",a9,7f,a6,91));
            				}
            			}
            		}
HXLINE( 105)		if (::hx::IsEq( _g1->get(HX_("startingAnimation",24,95,2d,77)),HX_("danceRight",a9,7f,a6,91) )) {
HXLINE( 106)			_g1->set(HX_("danceEvery",68,3f,07,1e),1);
            		}
HXLINE( 108)		 ::Dynamic replacer = null();
HXDLIN( 108)		::String fileContent = ::haxe::format::JsonPrinter_obj::print(_g1,replacer,HX_("\t",09,00,00,00));
HXLINE( 109)		::sys::io::File_obj::saveContent(((HX_("",00,00,00,00) + ::haxe::io::Path_obj::withoutExtension(fileName)) + HX_(" (converted).json",17,7c,78,d0)),fileContent);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Main_obj,psychToVSlice,(void))

void Main_obj::vsliceToPsych(::Array< ::String > args){
            	HX_GC_STACKFRAME(&_hx_pos_e47a9afac0942eb9_116_vsliceToPsych)
HXLINE( 117)		::String fileName;
HXDLIN( 117)		if ((args->length == 0)) {
HXLINE( 117)			fileName = ::Main_obj::awaitInput(HX_("V-Slice Character JSON:",d6,cc,9e,62));
            		}
            		else {
HXLINE( 117)			fileName = ::StringTools_obj::trim(args->__get(0));
            		}
HXLINE( 119)		if ((::haxe::io::Path_obj::extension(fileName) == HX_("",00,00,00,00))) {
HXLINE( 120)			fileName = (fileName + HX_(".json",56,f1,d6,c2));
            		}
HXLINE( 122)		 ::Dynamic vsliceJSON = null();
HXLINE( 124)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 125)			vsliceJSON =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(fileName))->doParse();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE( 127)				::Main_obj::closeWithMessage(HX_("ERROR: Invalid JSON Data.",23,75,b3,49),2,::Main_obj::FALIURE);
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 130)		 ::haxe::ds::StringMap _g1 =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN( 130)		_g1->set(HX_("animations",ef,34,1c,83),::cpp::VirtualArray_obj::__new(0));
HXDLIN( 130)		{
HXLINE( 130)			 ::Dynamic value;
HXLINE( 132)			 ::Dynamic tmp = vsliceJSON->__Field(HX_("isPixel",3c,6a,29,5f),::hx::paccDynamic);
HXDLIN( 132)			if (::hx::IsNotNull( tmp )) {
HXLINE( 130)				value = tmp;
            			}
            			else {
HXLINE( 130)				value = false;
            			}
HXDLIN( 130)			_g1->set(HX_("no_antialiasing",f2,74,67,98),value);
            		}
HXDLIN( 130)		_g1->set(HX_("image",5b,1f,69,bd), ::Dynamic(vsliceJSON->__Field(HX_("assetPath",b5,33,f8,ae),::hx::paccDynamic)));
HXDLIN( 130)		{
HXLINE( 130)			 ::Dynamic value1;
HXLINE( 134)			::cpp::VirtualArray tmp1 = ( (::cpp::VirtualArray)(vsliceJSON->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXDLIN( 134)			if (::hx::IsNotNull( tmp1 )) {
HXLINE( 130)				value1 = tmp1;
            			}
            			else {
HXLINE( 130)				value1 = ::cpp::VirtualArray_obj::__new(2)->init(0,0)->init(1,0);
            			}
HXDLIN( 130)			_g1->set(HX_("position",a9,a0,fa,ca),value1);
            		}
HXDLIN( 130)		{
HXLINE( 135)			 ::Dynamic value2;
HXDLIN( 135)			if (::hx::IsNotNull( vsliceJSON->__Field(HX_("healthIcon",35,ba,48,02),::hx::paccDynamic) )) {
HXLINE( 135)				value2 =  ::Dynamic( ::Dynamic(vsliceJSON->__Field(HX_("healthIcon",35,ba,48,02),::hx::paccDynamic))->__Field(HX_("id",db,5b,00,00),::hx::paccDynamic));
            			}
            			else {
HXLINE( 135)				value2 = HX_("face",9d,b4,b5,43);
            			}
HXLINE( 130)			_g1->set(HX_("healthicon",15,8e,6f,17),value2);
            		}
HXDLIN( 130)		{
HXLINE( 130)			 ::Dynamic value3;
HXLINE( 136)			 ::Dynamic tmp2 = vsliceJSON->__Field(HX_("flipX",0b,45,92,02),::hx::paccDynamic);
HXDLIN( 136)			if (::hx::IsNotNull( tmp2 )) {
HXLINE( 130)				value3 = tmp2;
            			}
            			else {
HXLINE( 130)				value3 = false;
            			}
HXDLIN( 130)			_g1->set(HX_("flip_x",26,2b,6a,3d),value3);
            		}
HXDLIN( 130)		_g1->set(HX_("healthbar_colors",78,d9,40,40),::cpp::VirtualArray_obj::__new(3)->init(0,255)->init(1,0)->init(2,0));
HXDLIN( 130)		{
HXLINE( 130)			 ::Dynamic value4;
HXLINE( 138)			::cpp::VirtualArray tmp3 = ( (::cpp::VirtualArray)(vsliceJSON->__Field(HX_("cameraOffsets",5b,39,62,df),::hx::paccDynamic)) );
HXDLIN( 138)			if (::hx::IsNotNull( tmp3 )) {
HXLINE( 130)				value4 = tmp3;
            			}
            			else {
HXLINE( 130)				value4 = ::cpp::VirtualArray_obj::__new(2)->init(0,0)->init(1,0);
            			}
HXDLIN( 130)			_g1->set(HX_("camera_position",c3,d4,4a,56),value4);
            		}
HXDLIN( 130)		{
HXLINE( 130)			 ::Dynamic value5;
HXLINE( 139)			 ::Dynamic tmp4 = vsliceJSON->__Field(HX_("singTime",fc,61,54,41),::hx::paccDynamic);
HXDLIN( 139)			if (::hx::IsNotNull( tmp4 )) {
HXLINE( 130)				value5 = tmp4;
            			}
            			else {
HXLINE( 130)				value5 = ((Float)6.1);
            			}
HXDLIN( 130)			_g1->set(HX_("sing_duration",84,ae,a8,66),value5);
            		}
HXDLIN( 130)		{
HXLINE( 130)			 ::Dynamic value6;
HXLINE( 140)			 ::Dynamic tmp5 = vsliceJSON->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic);
HXDLIN( 140)			if (::hx::IsNotNull( tmp5 )) {
HXLINE( 130)				value6 = tmp5;
            			}
            			else {
HXLINE( 130)				value6 = ((Float)1.0);
            			}
HXDLIN( 130)			_g1->set(HX_("scale",8a,ce,ce,78),value6);
            		}
HXLINE( 143)		::Array< ::String > images = ::Array_obj< ::String >::__new(0);
HXLINE( 145)		{
HXLINE( 145)			int _g2 = 0;
HXDLIN( 145)			::cpp::VirtualArray _g3 = ::hx::TCast< ::cpp::VirtualArray >::cast( ::Dynamic(vsliceJSON->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic)));
HXDLIN( 145)			while((_g2 < _g3->get_length())){
HXLINE( 145)				 ::Dynamic animation = _g3->__get(_g2);
HXDLIN( 145)				_g2 = (_g2 + 1);
HXLINE( 146)				::String anim = ( (::String)(animation->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) );
HXLINE( 147)				if (::StringTools_obj::endsWith(anim,HX_("-hold",ec,e3,1a,2e))) {
HXLINE( 147)					anim = ::StringTools_obj::replace(anim,HX_("-hold",ec,e3,1a,2e),HX_("-loop",11,c1,bf,30));
            				}
HXLINE( 151)				 ::Dynamic tmp6 = animation->__Field(HX_("looped",c3,5f,b9,61),::hx::paccDynamic);
HXDLIN( 151)				bool _hx_tmp;
HXDLIN( 151)				if (::hx::IsNotNull( tmp6 )) {
HXLINE( 151)					_hx_tmp = ( (bool)(tmp6) );
            				}
            				else {
HXLINE( 151)					_hx_tmp = false;
            				}
HXLINE( 154)				 ::Dynamic tmp7 = animation->__Field(HX_("frameRate",ad,11,25,39),::hx::paccDynamic);
HXDLIN( 154)				int _hx_tmp1;
HXDLIN( 154)				if (::hx::IsNotNull( tmp7 )) {
HXLINE( 154)					_hx_tmp1 = ( (int)(tmp7) );
            				}
            				else {
HXLINE( 154)					_hx_tmp1 = 24;
            				}
HXLINE( 155)				::cpp::VirtualArray tmp8 = ( (::cpp::VirtualArray)(animation->__Field(HX_("frameIndices",7a,06,df,83),::hx::paccDynamic)) );
HXDLIN( 155)				::cpp::VirtualArray _hx_tmp2;
HXDLIN( 155)				if (::hx::IsNotNull( tmp8 )) {
HXLINE( 155)					_hx_tmp2 = tmp8;
            				}
            				else {
HXLINE( 155)					_hx_tmp2 = ::cpp::VirtualArray_obj::__new(0);
            				}
HXLINE( 149)				_g1->get(HX_("animations",ef,34,1c,83))->__Field(HX_("push",da,11,61,4a),::hx::paccDynamic)( ::Dynamic(::hx::Anon_obj::Create(6)
            					->setFixed(0,HX_("offsets",80,09,65,d7), ::Dynamic(animation->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)))
            					->setFixed(1,HX_("indices",27,47,54,e3),_hx_tmp2)
            					->setFixed(2,HX_("fps",e9,c7,4d,00),_hx_tmp1)
            					->setFixed(3,HX_("anim",11,86,71,40),anim)
            					->setFixed(4,HX_("loop",64,a6,b7,47),_hx_tmp)
            					->setFixed(5,HX_("name",4b,72,ff,48), ::Dynamic(animation->__Field(HX_("prefix",92,d9,b6,ae),::hx::paccDynamic)))));
HXLINE( 158)				if (::hx::IsNotNull( animation->__Field(HX_("assetPath",b5,33,f8,ae),::hx::paccDynamic) )) {
HXLINE( 159)					images->push( ::Dynamic(animation->__Field(HX_("assetPath",b5,33,f8,ae),::hx::paccDynamic)));
            				}
            			}
            		}
HXLINE( 162)		{
HXLINE( 162)			int _g4 = 0;
HXDLIN( 162)			int _g5 = images->length;
HXDLIN( 162)			while((_g4 < _g5)){
HXLINE( 162)				_g4 = (_g4 + 1);
HXDLIN( 162)				int i = (_g4 - 1);
HXLINE( 164)				::String s = (::Std_obj::string(_g1->get(HX_("image",5b,1f,69,bd))) + HX_("",00,00,00,00));
HXDLIN( 164)				if ((s.indexOf(images->__get(i),null()) != -1)) {
HXLINE( 164)					continue;
            				}
HXLINE( 165)				{
HXLINE( 165)					::String value7 = ::Std_obj::string(_g1->get(HX_("image",5b,1f,69,bd)));
HXDLIN( 165)					::String value8;
HXDLIN( 165)					if ((i != (images->length - 1))) {
HXLINE( 165)						value8 = HX_(",",2c,00,00,00);
            					}
            					else {
HXLINE( 165)						value8 = HX_("",00,00,00,00);
            					}
HXDLIN( 165)					_g1->set(HX_("image",5b,1f,69,bd),((value7 + value8) + (HX_("",00,00,00,00) + images->__get(i))));
            				}
            			}
            		}
HXLINE( 168)		 ::Dynamic replacer = null();
HXDLIN( 168)		::String fileContent = ::haxe::format::JsonPrinter_obj::print(_g1,replacer,HX_("\t",09,00,00,00));
HXLINE( 169)		::sys::io::File_obj::saveContent(((HX_("",00,00,00,00) + ::haxe::io::Path_obj::withoutExtension(fileName)) + HX_(" (converted).json",17,7c,78,d0)),fileContent);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Main_obj,vsliceToPsych,(void))

::String Main_obj::awaitInput(::String message){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_176_awaitInput)
HXLINE( 177)		::Sys_obj::println(message);
HXLINE( 178)		::String input = ::Sys_obj::_hx_stdin()->readLine();
HXLINE( 179)		::Sys_obj::println(HX_("",00,00,00,00));
HXLINE( 180)		return input;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Main_obj,awaitInput,return )

void Main_obj::waitAndClose(Float waitTime,int code){
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_188_waitAndClose)
HXLINE( 189)		::Sys_obj::sleep(waitTime);
HXLINE( 190)		::Sys_obj::exit(code);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Main_obj,waitAndClose,(void))

void Main_obj::closeWithMessage(::String message,::hx::Null< Float >  __o_waitTime, ::Dynamic code){
            		Float waitTime = __o_waitTime.Default(((Float)1.0));
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_199_closeWithMessage)
HXLINE( 200)		::Sys_obj::println(message);
HXLINE( 201)		int _hx_tmp;
HXDLIN( 201)		if (::hx::IsNotNull( code )) {
HXLINE( 201)			_hx_tmp = ( (int)(code) );
            		}
            		else {
HXLINE( 201)			_hx_tmp = ::Main_obj::SUCCESS;
            		}
HXDLIN( 201)		::Main_obj::waitAndClose(waitTime,_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Main_obj,closeWithMessage,(void))


Main_obj::Main_obj()
{
}

bool Main_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"main") ) { outValue = main_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"FALIURE") ) { outValue = ( FALIURE ); return true; }
		if (HX_FIELD_EQ(inName,"SUCCESS") ) { outValue = ( SUCCESS ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"awaitInput") ) { outValue = awaitInput_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"waitAndClose") ) { outValue = waitAndClose_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"psychToVSlice") ) { outValue = psychToVSlice_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"vsliceToPsych") ) { outValue = vsliceToPsych_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"closeWithMessage") ) { outValue = closeWithMessage_dyn(); return true; }
	}
	return false;
}

bool Main_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"FALIURE") ) { FALIURE=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"SUCCESS") ) { SUCCESS=ioValue.Cast< int >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Main_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Main_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &Main_obj::FALIURE,HX_("FALIURE",d0,5d,06,4f)},
	{::hx::fsInt,(void *) &Main_obj::SUCCESS,HX_("SUCCESS",a3,f9,21,38)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Main_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Main_obj::FALIURE,"FALIURE");
	HX_MARK_MEMBER_NAME(Main_obj::SUCCESS,"SUCCESS");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Main_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Main_obj::FALIURE,"FALIURE");
	HX_VISIT_MEMBER_NAME(Main_obj::SUCCESS,"SUCCESS");
};

#endif

::hx::Class Main_obj::__mClass;

static ::String Main_obj_sStaticFields[] = {
	HX_("FALIURE",d0,5d,06,4f),
	HX_("SUCCESS",a3,f9,21,38),
	HX_("main",39,38,56,48),
	HX_("psychToVSlice",32,08,37,46),
	HX_("vsliceToPsych",04,41,71,73),
	HX_("awaitInput",d4,3c,8b,57),
	HX_("waitAndClose",f6,f4,79,13),
	HX_("closeWithMessage",89,ff,52,74),
	::String(null())
};

void Main_obj::__register()
{
	Main_obj _hx_dummy;
	Main_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("Main",59,64,2f,33);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Main_obj::__GetStatic;
	__mClass->mSetStaticField = &Main_obj::__SetStatic;
	__mClass->mMarkFunc = Main_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Main_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Main_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Main_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Main_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Main_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Main_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_21_boot)
HXDLIN(  21)		FALIURE = 1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_e47a9afac0942eb9_26_boot)
HXDLIN(  26)		SUCCESS = 0;
            	}
}

